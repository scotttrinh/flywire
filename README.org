* flywire

~flywire~ is the "arms and eyes" for automated agents (LLMs, copilots, CI harnesses) driving Emacs. It exposes a session-based API that can observe editor state, run interactive commands, and stream events back to an external controller.

The library separates *how* to drive Emacs (sessions, environments, actions, snapshots) from *why* you're doing it (agent logic). Examples below use an agentic coding flow (open a file, edit, save) but the interface is generic.

* Installation

** Doom Emacs

#+begin_src elisp
(package! flywire :recipe (:host github :repo "scotttrinh/flywire"))
#+end_src

Run ~doom sync~, then load it in ~config.el~:

#+begin_src elisp
(use-package! flywire)
#+end_src

** Straight.el

#+begin_src elisp
(straight-use-package
 '(flywire :type git :host github :repo "scotttrinh/flywire"))
#+end_src

* Core Concepts

- **Sessions**: A `flywire-session` is a driver instance with its own options, event handlers, and async handle tracking.
- **Environments**: A `flywire-session-env` decides *where* the session runs (current frame, dedicated agent frame, headless buffer). Flywire ships a default env; custom ones belong in your agent/frontend.
- **Actions**: Tools like `type_text`, `press_key`, `run_command`, `goto_location`, `cancel` plus any custom actions registered in the action registry.
- **Snapshots**: Structured views of Emacs (buffer content, cursor, minibuffer, windows, messages, processes). Profiles control how much data you collect.

* Quickstart

** Sync agentic step (open and edit a file)

#+begin_src elisp
(require 'flywire)

(let* ((session (flywire-session-create :snapshot-profile 'default))
       (result
        (flywire-session-exec
         session
         '(((action . "run_command") (name . "find-file"))
           ((action . "type_text") (text . "/tmp/demo.txt"))
           ((action . "press_key") (key . "RET"))
           ((action . "goto_location") (line . 10))
           ((action . "type_text") (text . ";; inserted by agent\n")))
         '(:snapshot-after t)))))
  ;; result is a plist: :status, :steps (with per-step snapshots/messages), :snapshot (final)
  (plist-get result :status))
#+end_src

** Async execution with events (react to minibuffer/idle)

#+begin_src elisp
(defun my-agent-handler (event)
  (pcase (plist-get event :type)
    (:step-end
     (message "Finished %s" (plist-get (plist-get event :result) :action)))
    (:minibuffer-open
     (message "Prompt: %s"
              (plist-get (plist-get event :snapshot) :minibuffer)))))

(let ((session (flywire-session-create :snapshot-profile 'minimal)))
  (flywire-session-on-event session #'my-agent-handler)
  ;; enable default minibuffer/idle events in the current frame
  (flywire-session-enable-events session)
  (let ((handle
         (flywire-session-start-async
          session
          '(((action . "run_command") (name . "execute-extended-command"))
            ((action . "type_text") (text . "save-buffer"))
            ((action . "press_key") (key . "RET"))))))
    ;; cancel if needed
    ;; (flywire-session-cancel session handle :reason "agent requested stop")
    handle))
#+end_src

* Configuration

** Snapshot profiles and extensions

- Profiles: `minimal`, `default`, `rich` (see `flywire-snapshot-profiles`). Supply `:snapshot-profile` when creating a session.
- Extend snapshots via `flywire-snapshot-collect-hook` to add agent-specific data.

** Safety policy

Gate interactive commands with `flywire-policy-allow-command-p` or a per-session override:

#+begin_src elisp
(setq flywire-policy-allow-command-p
      (lambda (cmd) (memq cmd '(find-file save-buffer))))

(flywire-session-create
 :safety-policy (lambda (cmd) (not (memq cmd '(delete-file kill-emacs)))))
#+end_src

** Action registry

Register custom tools (string tool names, plist args):

#+begin_src elisp
(flywire-action-register
 "run_tests"
 (lambda (args)
   (message "Run tests with opts: %S" args)))
#+end_src

* Status and gaps for agentic coding

- Sessions, environments, action registry, structured sync/async results, cancellation, and default minibuffer/idle events are implemented and covered by tests.
- The default environment targets the current frame; dedicated-frame or headless envs are expected to be provided by consuming packages (documentation/examples still to be written).

* Contributing

- Tests: ~nix run .#test~ (uses batch Emacs).
- Style: keep prefixes (`flywire-*`), prefer plists and string tool names, and include tests for new actions or env behavior.
- PRs/issues: describe the agent workflow youâ€™re enabling (e.g., dedicated-frame driver, CI headless run) so we can align environments and events.
